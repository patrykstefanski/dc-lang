#include <cstdio>
#include <cstdlib>
#include <getopt.h>
#include <vector>

#include "code_gen.hpp"
#include "cxx_extensions.hpp"
#include "instruction.hpp"
#include "interpreter.hpp"
#include "lexer.hpp"
#include "parser.hpp"
#include "utilities.hpp"

int jit_flag;
int debug_flag;

namespace {

int help_flag;
int dump_flag;

const option options[] = {
    {"help", no_argument, &help_flag, 1},
    {"jit", no_argument, &jit_flag, 1},
    {"dump", no_argument, &dump_flag, 1},
    {"debug", no_argument, &debug_flag, 1},
};

COLD void usage(const char* program_name) {
  std::fprintf(stderr,
               "Usage: %s [OPTION] FILE\n"
               "\n"
               "Options:\n"
               "  --help     Print this menu\n"
               "  --jit      Enable JIT\n"
               "  --dump     Dump generated bytecode\n"
               "  --debug    Print some debugging info\n",
               program_name);
}

COLD void dump(const std::vector<Instruction>& bytecode) {
  for (std::uint32_t i = 0; i < bytecode.size(); ++i) {
    std::printf("%04u ", i);
    bytecode[i].print(stdout);
    std::putchar('\n');
  }
}

}  // namespace

int main(int argc, char** argv) {
  const char* program_name = argv[0];
  // Parse options.
  int opt;
  int opt_index;
  while ((opt = getopt_long_only(argc, argv, "", options, &opt_index)) != -1) {
    switch (opt) {
    case 0:
      break;
    default:
      usage(program_name);
      return EXIT_FAILURE;
    }
  }
  if (help_flag != 0) {
    usage(program_name);
    return EXIT_FAILURE;
  }
  argc -= optind;
  argv += optind;
  if (UNLIKELY(argc != 1)) {
    usage(program_name);
    return EXIT_FAILURE;
  }
  // Initialize code gen.
  CodeGen::init();
  // Open the source file.
  const char* filename = argv[0];
  auto content = file_contents(filename);
  if (UNLIKELY(!content)) {
    std::fprintf(stderr, "Couldn't open the '%s' file\n", filename);
    return EXIT_FAILURE;
  }
  // Parse.
  Lexer lexer(content->c_str());
  Parser parser(std::move(lexer));
  parser.parse();
  if (dump_flag != 0) {
    dump(parser.bytecode());
    return EXIT_SUCCESS;
  }
  // Execute.
  return interpret(std::move(parser.bytecode()), std::move(parser.constants()));
}
